# -*- coding: utf-8 -*- 
# bot.py - Ø¨ÙˆØª Ù…ÙˆØ§ØµÙ„Ø§Øª Ø¨ÙˆØ±Ø³Ø¹ÙŠØ¯

import sys
import os
import logging
from enum import Enum, auto
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler, ConversationHandler,
    ContextTypes, MessageHandler, filters
)
from telegram.constants import ParseMode

# --- Fix for imports when running from a different directory ---
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# --- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù€ Logging ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", 
    level=logging.INFO,
    handlers=[
        logging.FileHandler('bot.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logging.getLogger("httpx").setLevel(logging.WARNING)
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# --- Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ÙˆØ§Ù„ØªÙˆÙƒÙ† ---
try:
    from config import BOT_TOKEN
    if not BOT_TOKEN or BOT_TOKEN == "YOUR_ACTUAL_BOT_TOKEN_HERE":
        logger.error("BOT_TOKEN not properly configured in config.py")
        raise ValueError("BOT_TOKEN is not configured properly")
except ImportError:
    logger.error("!!! Ø®Ø·Ø£ ÙØ§Ø¯Ø­: Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„Ù 'config.py' Ø£Ùˆ Ù…ØªØºÙŠØ± 'BOT_TOKEN' Ø¨Ø¯Ø§Ø®Ù„Ù‡.")
    logger.error("!!! ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ù†Ø´Ø§Ø¡ Ù…Ù„Ù 'config.py' ÙÙŠ Ù†ÙØ³ Ø§Ù„Ù…Ø¬Ù„Ø¯ ÙˆÙˆØ¶Ø¹ 'BOT_TOKEN = \"YourToken\"' Ø¨Ø¯Ø§Ø®Ù„Ù‡.")
    exit(1)
except ValueError as e:
    logger.error(f"!!! Ø®Ø·Ø£ ÙÙŠ Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„ØªÙˆÙƒÙ†: {e}")
    exit(1)

try:
    from data import routes_data, neighborhood_data
    from helpers import build_keyboard, find_route_logic
    
    if not routes_data or not isinstance(routes_data, list):
        logger.error("routes_data is empty or not a list")
        raise ValueError("Invalid routes_data")
    
    if not neighborhood_data or not isinstance(neighborhood_data, dict):
        logger.error("neighborhood_data is empty or not a dict")
        raise ValueError("Invalid neighborhood_data")
        
    logger.info(f"Successfully loaded {len(routes_data)} routes and {len(neighborhood_data)} neighborhoods")
    
except ImportError as e:
    logger.error(f"!!! Ø®Ø·Ø£ ÙØ§Ø¯Ø­: Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù…Ù„ÙØ§Øª ('data.py' Ø£Ùˆ 'helpers.py') Ø£Ùˆ Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø© Ø¨Ø¯Ø§Ø®Ù„Ù‡Ø§: {e}")
    exit(1)
except Exception as e:
    logger.error(f"!!! Ø®Ø·Ø£ ÙØ§Ø¯Ø­ Ø£Ø«Ù†Ø§Ø¡ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: {e}")
    exit(1)

# --- ØªØ¹Ø±ÙŠÙ Ø§Ù„Ø­Ø§Ù„Ø§Øª (States) Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Enum ---
class States(Enum):
    SELECTING_START_NEIGHBORHOOD = auto()
    SELECTING_START_CATEGORY = auto()
    SELECTING_START_LANDMARK = auto()
    SELECTING_END_NEIGHBORHOOD = auto()
    SELECTING_END_CATEGORY = auto()
    SELECTING_END_LANDMARK = auto()

# --- Ø§Ù„Ø¯ÙˆØ§Ù„ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© ---

def validate_data_integrity():
    """Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† ØµØ­Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª Ø§Ù„Ù…Ø³ØªÙˆØ±Ø¯Ø©"""
    try:
        for i, route in enumerate(routes_data):
            if not isinstance(route, dict):
                logger.error(f"Route {i} is not a dictionary")
                return False
            required_keys = ['routeName', 'keyPoints', 'fare']
            for key in required_keys:
                if key not in route:
                    logger.error(f"Route {i} missing required key: {key}")
                    return False
        
        for neighborhood, categories in neighborhood_data.items():
            if not isinstance(categories, dict):
                logger.error(f"Neighborhood '{neighborhood}' categories is not a dictionary")
                return False
            for category, landmarks in categories.items():
                if not isinstance(landmarks, list):
                    logger.error(f"Category '{category}' in '{neighborhood}' is not a list")
                    return False
        
        logger.info("Data integrity validation passed")
        return True
    except Exception as e:
        logger.error(f"Error during data validation: {e}")
        return False

# --- Ù…Ø¹Ø§Ù„Ø¬Ø§Øª Ø§Ù„Ø£Ø­Ø¯Ø§Ø« ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø¨Ø¯Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø© Ø£Ùˆ Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©"""
    user = update.effective_user
    logger.info(f"User {user.first_name} (ID: {user.id}) started or returned to start.")
    
    keyboard = build_keyboard(list(neighborhood_data.keys()), "start_neighborhood")
    text = "ðŸšŒ Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Ù…ÙˆØ§ØµÙ„Ø§Øª Ø¨ÙˆØ±Ø³Ø¹ÙŠØ¯!\n\nØ§Ø®ØªØ± Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©:"
    
    if update.callback_query:
        await update.callback_query.edit_message_text(text, reply_markup=keyboard)
    else:
        await update.message.reply_text(text, reply_markup=keyboard)
        
    return States.SELECTING_START_NEIGHBORHOOD

async def select_start_neighborhood(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø§Ø®ØªÙŠØ§Ø± Ø­ÙŠ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©"""
    query = update.callback_query
    await query.answer()
    
    chosen_neighborhood = query.data.split(":", 1)[1]
    context.user_data['start_neighborhood'] = chosen_neighborhood
    logger.info(f"User {update.effective_user.first_name} selected start neighborhood: {chosen_neighborhood}")
    
    categories = list(neighborhood_data[chosen_neighborhood].keys())
    keyboard = build_keyboard(categories, "start_category", back_target="start")
    
    await query.edit_message_text(
        f"ðŸ˜ï¸ Ø§Ù„Ø­ÙŠ Ø§Ù„Ù…Ø®ØªØ§Ø±: {chosen_neighborhood}\n\nØ§Ø®ØªØ± Ø§Ù„ØªØµÙ†ÙŠÙ:",
        reply_markup=keyboard
    )
    return States.SELECTING_START_CATEGORY

async def select_start_category(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø§Ø®ØªÙŠØ§Ø± ØªØµÙ†ÙŠÙ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©"""
    query = update.callback_query
    await query.answer()
    
    chosen_category = query.data.split(":", 1)[1]
    start_neighborhood = context.user_data.get('start_neighborhood')
    context.user_data['start_category'] = chosen_category
    logger.info(f"User {update.effective_user.first_name} selected start category: {chosen_category}")

    landmarks = neighborhood_data[start_neighborhood][chosen_category]
    keyboard = build_keyboard(landmarks, "start_landmark", back_target="start_neighborhood")
    
    await query.edit_message_text(
        f"ðŸ˜ï¸ Ø§Ù„Ø­ÙŠ: {start_neighborhood}\nðŸ“‚ Ø§Ù„ØªØµÙ†ÙŠÙ: {chosen_category}\n\nØ§Ø®ØªØ± Ø§Ù„Ù…Ø¹Ù„Ù…:",
        reply_markup=keyboard
    )
    return States.SELECTING_START_LANDMARK

async def select_start_landmark(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø§Ø®ØªÙŠØ§Ø± Ù…Ø¹Ù„Ù… Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©"""
    query = update.callback_query
    await query.answer()
    
    chosen_landmark = query.data.split(":", 1)[1]
    context.user_data['start_landmark'] = chosen_landmark
    logger.info(f"User {update.effective_user.first_name} selected start landmark: {chosen_landmark}")

    keyboard = build_keyboard(list(neighborhood_data.keys()), "end_neighborhood", back_target="start_category")
    
    await query.edit_message_text(
        f"âœ… Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©: {chosen_landmark}\n\nØ§Ø®ØªØ± Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©:",
        reply_markup=keyboard
    )
    return States.SELECTING_END_NEIGHBORHOOD

async def select_end_neighborhood(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø§Ø®ØªÙŠØ§Ø± Ø­ÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©"""
    query = update.callback_query
    await query.answer()
    
    chosen_neighborhood = query.data.split(":", 1)[1]
    context.user_data['end_neighborhood'] = chosen_neighborhood
    logger.info(f"User {update.effective_user.first_name} selected end neighborhood: {chosen_neighborhood}")
    
    categories = list(neighborhood_data[chosen_neighborhood].keys())
    keyboard = build_keyboard(categories, "end_category", back_target="start_landmark")
    
    await query.edit_message_text(
        f"ðŸ˜ï¸ Ø§Ù„Ø­ÙŠ Ø§Ù„Ù…Ø®ØªØ§Ø±: {chosen_neighborhood}\n\nØ§Ø®ØªØ± Ø§Ù„ØªØµÙ†ÙŠÙ:",
        reply_markup=keyboard
    )
    return States.SELECTING_END_CATEGORY

async def select_end_category(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø§Ø®ØªÙŠØ§Ø± ØªØµÙ†ÙŠÙ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©"""
    query = update.callback_query
    await query.answer()
    
    chosen_category = query.data.split(":", 1)[1]
    end_neighborhood = context.user_data.get('end_neighborhood')
    context.user_data['end_category'] = chosen_category
    logger.info(f"User selected end category: {chosen_category}")

    landmarks = neighborhood_data[end_neighborhood][chosen_category]
    keyboard = build_keyboard(landmarks, "end_landmark", back_target="end_neighborhood")
    
    await query.edit_message_text(
        f"ðŸ˜ï¸ Ø§Ù„Ø­ÙŠ: {end_neighborhood}\nðŸ“‚ Ø§Ù„ØªØµÙ†ÙŠÙ: {chosen_category}\n\nØ§Ø®ØªØ± Ø§Ù„Ù…Ø¹Ù„Ù…:",
        reply_markup=keyboard
    )
    return States.SELECTING_END_LANDMARK

async def select_end_landmark_and_find_route(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Ø§Ø®ØªÙŠØ§Ø± Ù…Ø¹Ù„Ù… Ø§Ù„Ù†Ù‡Ø§ÙŠØ© ÙˆØ§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø§Ù„Ø·Ø±ÙŠÙ‚"""
    query = update.callback_query
    await query.answer()
    
    chosen_end_landmark = query.data.split(":", 1)[1]
    start_landmark = context.user_data.get('start_landmark')
    logger.info(f"User {update.effective_user.first_name} selected end landmark: {chosen_end_landmark}")

    await query.edit_message_text(text="ðŸ” Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø¨Ø­Ø« Ø¹Ù† Ø£ÙØ¶Ù„ Ø·Ø±ÙŠÙ‚...")
    
    result = find_route_logic(start_landmark, chosen_end_landmark, routes_data)
    
    query_text = f"{chosen_end_landmark} Ø¨ÙˆØ±Ø³Ø¹ÙŠØ¯ Ù…ØµØ±"
    destination_map_url = f"https://www.google.com/maps/search/{query_text.replace(' ', '+')}"
    keyboard = [[InlineKeyboardButton("ðŸ—ºï¸ Ø¹Ø±Ø¶ Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø±ÙŠØ·Ø©", url=destination_map_url)]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    await query.edit_message_text(
        text=f"ðŸŽ¯ **Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¨Ø­Ø«**\n\n{result}",
        reply_markup=reply_markup,
        parse_mode=ParseMode.MARKDOWN
    )
    return ConversationHandler.END


# --- Ø¯ÙˆØ§Ù„ Ø§Ù„ØªÙ†Ù‚Ù„ Ù„Ù„Ø®Ù„Ù ---

async def _go_back_to_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©."""
    return await start(update, context)

async def _go_back_to_start_category_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØªØµÙ†ÙŠÙ Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©."""
    query = update.callback_query
    chosen_neighborhood = context.user_data.get('start_neighborhood')
    categories = list(neighborhood_data[chosen_neighborhood].keys())
    keyboard = build_keyboard(categories, "start_category", back_target="start")
    await query.edit_message_text(
        f"ðŸ˜ï¸ Ø§Ù„Ø­ÙŠ Ø§Ù„Ù…Ø®ØªØ§Ø±: {chosen_neighborhood}\n\nØ§Ø®ØªØ± Ø§Ù„ØªØµÙ†ÙŠÙ:",
        reply_markup=keyboard
    )
    return States.SELECTING_START_CATEGORY

async def _go_back_to_start_landmark_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ù…Ø¹Ù„Ù… Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©."""
    query = update.callback_query
    start_neighborhood = context.user_data.get('start_neighborhood')
    chosen_category = context.user_data.get('start_category')
    landmarks = neighborhood_data[start_neighborhood][chosen_category]
    keyboard = build_keyboard(landmarks, "start_landmark", back_target="start_neighborhood")
    await query.edit_message_text(
        f"ðŸ˜ï¸ Ø§Ù„Ø­ÙŠ: {start_neighborhood}\nðŸ“‚ Ø§Ù„ØªØµÙ†ÙŠÙ: {chosen_category}\n\nØ§Ø®ØªØ± Ø§Ù„Ù…Ø¹Ù„Ù…:",
        reply_markup=keyboard
    )
    return States.SELECTING_START_LANDMARK

async def _go_back_to_end_neighborhood_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ø®ØªÙŠØ§Ø± Ø­ÙŠ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©."""
    query = update.callback_query
    chosen_landmark = context.user_data.get('start_landmark')
    keyboard = build_keyboard(list(neighborhood_data.keys()), "end_neighborhood", back_target="start_category")
    await query.edit_message_text(
        f"âœ… Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©: {chosen_landmark}\n\nØ§Ø®ØªØ± Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©:",
        reply_markup=keyboard
    )
    return States.SELECTING_END_NEIGHBORHOOD

async def _go_back_to_end_category_selection(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØªØµÙ†ÙŠÙ Ø§Ù„Ù†Ù‡Ø§ÙŠØ©."""
    query = update.callback_query
    chosen_neighborhood = context.user_data.get('end_neighborhood')
    categories = list(neighborhood_data[chosen_neighborhood].keys())
    keyboard = build_keyboard(categories, "end_category", back_target="start_landmark")
    await query.edit_message_text(
        f"ðŸ˜ï¸ Ø§Ù„Ø­ÙŠ Ø§Ù„Ù…Ø®ØªØ§Ø±: {chosen_neighborhood}\n\nØ§Ø®ØªØ± Ø§Ù„ØªØµÙ†ÙŠÙ:",
        reply_markup=keyboard
    )
    return States.SELECTING_END_CATEGORY

# Ø®Ø±ÙŠØ·Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø§Ù„ØªÙ†Ù‚Ù„ Ù„Ù„Ø®Ù„Ù
back_map = {
    "start": _go_back_to_start,
    "start_neighborhood": _go_back_to_start_category_selection,
    "start_category": _go_back_to_start_landmark_selection,
    "start_landmark": _go_back_to_end_neighborhood_selection,
    "end_neighborhood": _go_back_to_end_category_selection,
}

async def go_back(update: Update, context: ContextTypes.DEFAULT_TYPE) -> States:
    """Ø§Ù„Ø¹ÙˆØ¯Ø© Ø¥Ù„Ù‰ Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„Ø³Ø§Ø¨Ù‚Ø© Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… back_map."""
    query = update.callback_query
    await query.answer()
    
    target = query.data.split(":", 1)[1]
    logger.info(f"User {update.effective_user.first_name} going back to: {target}")

    handler = back_map.get(target)
    if handler:
        return await handler(update, context)
    
    logger.warning(f"Unknown back target: {target}")
    return await start(update, context)


async def pagination_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles pagination button clicks."""
    query = update.callback_query
    await query.answer()

    try:
        _, prefix, page_str, back_target = query.data.split(':', 3)
        page = int(page_str)
        if back_target == '':
            back_target = None
    except ValueError:
        logger.error(f"Error parsing pagination callback data: {query.data}")
        return

    items = []
    text = ""
    current_state = None
    
    # Reconstruct the items and text based on the prefix
    if prefix == "start_neighborhood":
        items = list(neighborhood_data.keys())
        text = "ðŸšŒ Ù…Ø±Ø­Ø¨Ø§Ù‹ Ø¨Ùƒ ÙÙŠ Ø¨ÙˆØª Ù…ÙˆØ§ØµÙ„Ø§Øª Ø¨ÙˆØ±Ø³Ø¹ÙŠØ¯!\n\nØ§Ø®ØªØ± Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©:"
        current_state = States.SELECTING_START_NEIGHBORHOOD
    
    elif prefix == "start_category":
        start_neighborhood = context.user_data.get('start_neighborhood')
        if not start_neighborhood:
            await query.edit_message_text("Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ /start")
            return ConversationHandler.END
        items = list(neighborhood_data[start_neighborhood].keys())
        text = f"ðŸ˜ï¸ Ø§Ù„Ø­ÙŠ Ø§Ù„Ù…Ø®ØªØ§Ø±: {start_neighborhood}\n\nØ§Ø®ØªØ± Ø§Ù„ØªØµÙ†ÙŠÙ:"
        current_state = States.SELECTING_START_CATEGORY

    elif prefix == "start_landmark":
        start_neighborhood = context.user_data.get('start_neighborhood')
        start_category = context.user_data.get('start_category')
        if not all([start_neighborhood, start_category]):
            await query.edit_message_text("Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ /start")
            return ConversationHandler.END
        items = neighborhood_data[start_neighborhood][start_category]
        text = f"ðŸ˜ï¸ Ø§Ù„Ø­ÙŠ: {start_neighborhood}\nðŸ“‚ Ø§Ù„ØªØµÙ†ÙŠÙ: {start_category}\n\nØ§Ø®ØªØ± Ø§Ù„Ù…Ø¹Ù„Ù…:"
        current_state = States.SELECTING_START_LANDMARK

    elif prefix == "end_neighborhood":
        start_landmark = context.user_data.get('start_landmark')
        items = list(neighborhood_data.keys())
        text = f"âœ… Ù†Ù‚Ø·Ø© Ø§Ù„Ø¨Ø¯Ø§ÙŠØ©: {start_landmark}\n\nØ§Ø®ØªØ± Ù†Ù‚Ø·Ø© Ø§Ù„Ù†Ù‡Ø§ÙŠØ©:"
        current_state = States.SELECTING_END_NEIGHBORHOOD

    elif prefix == "end_category":
        end_neighborhood = context.user_data.get('end_neighborhood')
        if not end_neighborhood:
            await query.edit_message_text("Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ /start")
            return ConversationHandler.END
        items = list(neighborhood_data[end_neighborhood].keys())
        text = f"ðŸ˜ï¸ Ø§Ù„Ø­ÙŠ Ø§Ù„Ù…Ø®ØªØ§Ø±: {end_neighborhood}\n\nØ§Ø®ØªØ± Ø§Ù„ØªØµÙ†ÙŠÙ:"
        current_state = States.SELECTING_END_CATEGORY

    elif prefix == "end_landmark":
        end_neighborhood = context.user_data.get('end_neighborhood')
        end_category = context.user_data.get('end_category')
        if not all([end_neighborhood, end_category]):
            await query.edit_message_text("Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ /start")
            return ConversationHandler.END
        items = neighborhood_data[end_neighborhood][end_category]
        text = f"ðŸ˜ï¸ Ø§Ù„Ø­ÙŠ: {end_neighborhood}\nðŸ“‚ Ø§Ù„ØªØµÙ†ÙŠÙ: {end_category}\n\nØ§Ø®ØªØ± Ø§Ù„Ù…Ø¹Ù„Ù…:"
        current_state = States.SELECTING_END_LANDMARK

    else:
        logger.warning(f"Unknown prefix for pagination: {prefix}")
        await query.edit_message_text("Ø­Ø¯Ø« Ø®Ø·Ø£ØŒ ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯ /start")
        return ConversationHandler.END

    keyboard = build_keyboard(items, prefix, back_target, page=page)
    await query.edit_message_text(text, reply_markup=keyboard)
    return current_state

async def noop_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handles no-operation callbacks, like page numbers."""
    await update.callback_query.answer()


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©"""
    user_first_name = update.effective_user.first_name
    logger.info(f"User {user_first_name} canceled the conversation.")
    
    text = "âŒ ØªÙ… Ø¥Ù„ØºØ§Ø¡ Ø§Ù„Ù…Ø­Ø§Ø¯Ø«Ø©. Ø§Ø³ØªØ®Ø¯Ù… /start Ù„Ù„Ø¨Ø¯Ø¡ Ù…Ù† Ø¬Ø¯ÙŠØ¯."
    if update.callback_query:
        await update.callback_query.edit_message_text(text)
    else:
        await update.message.reply_text(text)

    return ConversationHandler.END

async def handle_unexpected_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ù†ØµÙˆØµ ØºÙŠØ± Ø§Ù„Ù…ØªÙˆÙ‚Ø¹Ø©"""
    logger.info(f"Unexpected text from {update.effective_user.first_name}: {update.message.text}")
    await update.message.reply_text("Ù…Ù† ÙØ¶Ù„Ùƒ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£Ø²Ø±Ø§Ø± Ù„Ù„Ø§Ø®ØªÙŠØ§Ø±ØŒ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… /cancel Ù„Ù„Ø¥Ù„ØºØ§Ø¡.")

# --- Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© main --- 
def main() -> None: 
    """ÙŠØ´ØºÙ„ Ø§Ù„Ø¨ÙˆØª."""
    # Set CWD to the script's directory to fix file path issues
    os.chdir(os.path.dirname(os.path.abspath(__file__)))

    if not validate_data_integrity():
        logger.error("Data validation failed. Bot cannot start.")
        return
    
    application = Application.builder().token(BOT_TOKEN).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler('start', start)],
        states={
            States.SELECTING_START_NEIGHBORHOOD: [CallbackQueryHandler(select_start_neighborhood, pattern=r'^start_neighborhood:')],
            States.SELECTING_START_CATEGORY: [CallbackQueryHandler(select_start_category, pattern=r'^start_category:')],
            States.SELECTING_START_LANDMARK: [CallbackQueryHandler(select_start_landmark, pattern=r'^start_landmark:')],
            States.SELECTING_END_NEIGHBORHOOD: [CallbackQueryHandler(select_end_neighborhood, pattern=r'^end_neighborhood:')],
            States.SELECTING_END_CATEGORY: [CallbackQueryHandler(select_end_category, pattern=r'^end_category:')],
            States.SELECTING_END_LANDMARK: [CallbackQueryHandler(select_end_landmark_and_find_route, pattern=r'^end_landmark:')],
        },
        fallbacks=[
            CommandHandler('cancel', cancel),
            CallbackQueryHandler(cancel, pattern=r'^cancel_action

if __name__ == '__main__':
    main()
),
            CallbackQueryHandler(go_back, pattern=r'^go_back_to:'),
            CallbackQueryHandler(pagination_handler, pattern=r'^page:'),
            CallbackQueryHandler(noop_handler, pattern=r'^noop

if __name__ == '__main__':
    main()
),
            MessageHandler(filters.TEXT & ~filters.COMMAND, handle_unexpected_text),
        ],
    )

    application.add_handler(conv_handler)
    
    logger.info("Bot starting with pagination and back button functionality...")
    application.run_polling()


if __name__ == '__main__':
    main()
